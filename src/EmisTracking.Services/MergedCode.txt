emission-tracking-app\src\EmisTracking.Services\Constants.cs 
 
﻿namespace EmisTracking.Services
{
    public static class Constants
    {
        public const int MinPageNumber = 1;
        public const int DefaultPageSize = 10;
        public const int MinPageSize = 5;

        public const string UserIdClaimType = "userId";
        public const string RoleInfoClaimType = "roleInfo";

        public const string AdminRole = "Администратор";
        public const string EditorRole = "Редактор";
        // FIXME Добавить ролей

        public const double DefaultParameterValue = 0.0d;
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\Area.cs 
 
﻿namespace EmisTracking.Services.Entities
{
    public class Area : BaseEntity
    {
        public int Number { get; set; }

        public string Name { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\BaseEntity.cs 
 
﻿using EmisTracking.Services.Interfaces;
using System;
using System.ComponentModel.DataAnnotations;

namespace EmisTracking.Services.Entities
{
    public abstract class BaseEntity : IEntity
    {
        [Key]
        [Required]
        [MaxLength(36)] // GUID length
        public string Id { get; set; } = Guid.NewGuid().ToString();
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\Consumption.cs 
 
﻿namespace EmisTracking.Services.Entities
{
    public class Consumption : BaseEntity
    {
        public string ConsumptionGroupId { get; set; }
        public virtual ConsumptionGroup ConsumptionGroup { get; set; }

        public double Mass { get; set; }

        public int Month { get; set; }

        public int Year { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\ConsumptionGroup.cs 
 
﻿namespace EmisTracking.Services.Entities
{
    public class ConsumptionGroup : BaseEntity
    {
        public string MethodologyId { get; set; }
        public virtual Methodology Methodology { get; set; }

        public string Name { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\EmissionSource.cs 
 
﻿using EmisTracking.Services.Enums;

namespace EmisTracking.Services.Entities
{
    public class EmissionSource : BaseEntity
    {
        public string Number { get; set; }

        public string SubdivisionId { get; set; }
        public virtual Subdivision Subdivision { get; set; }

        public string Name { get; set; }

        public ProcessCategory ProcessCategory { get; set; }

        public string MethodologyId { get; set; }
        public virtual Methodology Methodology { get; set; }

        public string ModeId { get; set; }
        public virtual Mode Mode { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\GrossEmission.cs 
 
﻿using System;

namespace EmisTracking.Services.Entities
{
    public class GrossEmission : BaseEntity
    {
        public string SourceSubstanceId { get; set; }
        public virtual SourceSubstance SourceSubstance { get; set; }

        public string MethodologyId { get; set; }
        public virtual Methodology Methodology { get; set; }

        public double Mass { get; set; }

        public int Month { get; set; }

        public int Year { get; set; }

        public string TaxId { get; set; }
        public virtual Tax Tax { get; set; }

        public DateTime CalculationDate { get; set; } = DateTime.Now;
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\Methodology.cs 
 
﻿namespace EmisTracking.Services.Entities
{
    public class Methodology : BaseEntity
    {
        public string ShortName { get; set; }

        public string Name { get; set; }

        public string ModeId { get; set; }

        public virtual Mode Mode { get; set; }

        public string Formula { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\MethodologyParameter.cs 
 
﻿using EmisTracking.Services.Enums;

namespace EmisTracking.Services.Entities
{
    public class MethodologyParameter : BaseEntity
    {
        public string MethodologyId { get; set; }
        public virtual Methodology Methodology { get; set; }

        public ParameterType ParameterType { get; set; }

        public string Name { get; set; }

        public string FormulaName { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\Mode.cs 
 
﻿using EmisTracking.Services.Enums;

namespace EmisTracking.Services.Entities
{
    public class Mode : BaseEntity
    {
        public string Name { get; set; }

        public ProcessCategory ProcessCategory { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\OperatingTime.cs 
 
﻿namespace EmisTracking.Services.Entities
{
    public class OperatingTime : BaseEntity
    {
        public string EmissionSourceId { get; set; }
        public virtual EmissionSource EmissionSource { get; set; }

        public int Month { get; set; }

        public int Year { get; set; }

        public double Hours { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\ParameterValue.cs 
 
﻿namespace EmisTracking.Services.Entities
{
    public class ParameterValue : BaseEntity
    {
        public string MethodologyParameterId { get; set; }
        public virtual MethodologyParameter MethodologyParameter { get; set; }

        public int Month { get; set; }

        public int Year { get; set; }

        public double Value { get; set; }

        public string SourceSubstanceId { get; set; }
        public virtual SourceSubstance SourceSubstance { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\Pollutant.cs 
 
﻿using EmisTracking.Services.Enums;

namespace EmisTracking.Services.Entities
{
    public class Pollutant : BaseEntity
    {
        public string Name { get; set; }

        public string Formula { get; set; }

        public HazardClass HazardClass { get; set; }

        public AggregateState AggregateState { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\SourceSubstance.cs 
 
﻿using EmisTracking.Services.Enums;

namespace EmisTracking.Services.Entities
{
    public class SourceSubstance : BaseEntity
    {
        public string EmissionSourceId { get; set; }
        public virtual EmissionSource EmissionSource { get; set; }

        public string PollutantId { get; set; }
        public virtual Pollutant Pollutant { get; set; }

        public bool IsRegulated { get; set; }

        public GasCleaningUnitType GasCleaningUnitType { get; set; }

        public double PurificationPercentage { get; set; }

        public double AnnualAmount { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\SpecificIndicator.cs 
 
﻿namespace EmisTracking.Services.Entities
{
    public class SpecificIndicator : BaseEntity
    {
        public string Name { get; set; }

        public string ConsumptionGroupId { get; set; }
        public virtual ConsumptionGroup ConsumptionGroup { get; set; }

        public string PollutantId { get; set; }
        public virtual Pollutant Pollutant { get; set; }

        public double Value { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\Subdivision.cs 
 
﻿namespace EmisTracking.Services.Entities
{
    public class Subdivision : BaseEntity
    {
        public string AreaId { get; set; }
        public virtual Area Area { get; set; }

        public string Name { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\SystemUser.cs 
 
﻿using EmisTracking.Services.Interfaces;
using Microsoft.AspNetCore.Identity;
using System.ComponentModel.DataAnnotations;

namespace EmisTracking.Services.Entities
{
    public class SystemUser : IdentityUser, IEntity
    {
        [Required]
        public string FirstName { get; set; }

        public string FirstNameInitial => $"{FirstName[0]}.";

        public string MiddleName { get; set; }
        public string MiddleNameInitial => MiddleName.Length != 0 ? (MiddleName[0] + ".") : string.Empty;

        [Required]
        public string LastName { get; set; }

        public string FullName => $"{FirstNameInitial}{MiddleNameInitial}{LastName}";
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\Tax.cs 
 
﻿using EmisTracking.Services.Enums;
using System;

namespace EmisTracking.Services.Entities
{
    public class Tax : BaseEntity
    {
        public int Month { get; set; }

        public int Year { get; set; }

        public double TotalAmount { get; set; }

        public DateTime CalculationDate { get; set; } = DateTime.Now;

        public HazardClass HazardClass { get; set; }

        public bool IsPaid { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\TaxRate.cs 
 
﻿using EmisTracking.Services.Enums;
using System;

namespace EmisTracking.Services.Entities
{
    public class TaxRate : BaseEntity
    {
        public HazardClass HazardClass { get; set; }

        public double Amount { get; set; }

        public DateTime StartDate { get; set; }

        public DateTime? EndDate { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Entities\User.cs 
 
﻿using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace EmisTracking.Services.Entities
{
    [Table("Users")]
    public class User : BaseEntity
    {
        [Required]
        public string SystemUserId { get; set; }

        public string Info { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Enums\AggregateState.cs 
 
﻿namespace EmisTracking.Services.Enums
{
    public enum AggregateState
    {
        Solid = 1,
        Liquid = 2,
        Gas = 3
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Enums\GasCleaningUnitType.cs 
 
﻿namespace EmisTracking.Services.Enums
{
    public enum GasCleaningUnitType
    {
        No = 0,
        Yes = 1,
        Other = 2
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Enums\HazardClass.cs 
 
﻿namespace EmisTracking.Services.Enums
{
    public enum HazardClass
    {
        I = 1,
        II = 2,
        III = 3,
        IV = 4
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Enums\ParameterType.cs 
 
﻿namespace EmisTracking.Services.Enums
{
    public enum ParameterType
    {
        Numeric = 1,
        GasCleaningUnitPercent = 2,
        ConsumptionMass = 3,
        OperatingTime = 4,
        SpecificIndicator = 5,
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Enums\ProcessCategory.cs 
 
﻿namespace EmisTracking.Services.Enums
{
    public enum ProcessCategory
    {
        None = 0,
        BurningFuel = 1,
        WasteProcessing = 2,
        AgriculturalObject = 3,
        TechnologicalProcess = 4,
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Exceptions\BusinessLogicException.cs 
 
﻿using System;
using System.Collections.Generic;

namespace EmisTracking.Services.Exceptions
{

    public class BusinessLogicException : Exception
    {
        public BusinessLogicException()
        {
        }

        public BusinessLogicException(string message) : base(message)
        {
        }

        public BusinessLogicException(string message, Exception innerException) : base(message, innerException)
        {
        }

        public List<FieldError> FieldErrors { get; set; }

        public string SerializedData { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Exceptions\FieldError.cs 
 
﻿namespace EmisTracking.Services.Exceptions
{
    public class FieldError
    {
        public string Field { get; set; }

        public string Message { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Interfaces\IEntity.cs 
 
﻿namespace EmisTracking.Services.Interfaces
{
    public interface IEntity
    {
        public string Id { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Interfaces\IEntityService.cs 
 
﻿using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Threading.Tasks;

namespace EmisTracking.Services.Interfaces
{
    public interface IEntityService<TEntity>
    {
        Task<TEntity> GetByIdAsync(string id, bool loadDependencies = false);

        Task<string> AddAsync(TEntity entity);

        Task<bool> UpdateAsync(TEntity entity);

        Task<bool> DeleteAsync(string id);

        Task<List<TEntity>> GetAllAsync(Expression<Func<TEntity, bool>> predicate = null, bool loadDependencies = false);
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Interfaces\IRepository.cs 
 
﻿using System;
using System.Linq;
using System.Linq.Expressions;
using System.Threading.Tasks;

namespace EmisTracking.Services.Interfaces
{
    public interface IRepository<TEntity>
        where TEntity : class, IEntity
    {
        Task<string> CreateAsync(TEntity entity);

        IQueryable<TEntity> GetAll(Expression<Func<TEntity, bool>> predicate = null,
            params Expression<Func<TEntity, object>>[] includes);

        Task<TEntity> GetByIdAsync(string entityId,
            params Expression<Func<TEntity, object>>[] includes);

        Task<bool> UpdateAsync(TEntity entity);

        Task<bool> DeleteAsync(string entityId);
    }
}
 
emission-tracking-app\src\EmisTracking.Services\JwtAuth\JwtTokenService.cs 
 
﻿using EmisTracking.Services.Entities;
using EmisTracking.Services.Options;
using Microsoft.Extensions.Options;
using Microsoft.IdentityModel.Tokens;
using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens.Jwt;
using System.Linq;
using System.Security.Claims;
using System.Text;

namespace EmisTracking.Services.JwtAuth
{
    public class JwtTokenService
    {
        private const int DaysExpirationTerm = 50;
        private readonly JwtTokenSettings _settings;

        public JwtTokenService(IOptions<JwtTokenSettings> options)
        {
            if (options != null)
            {
                _settings = options.Value;
            }
        }

        public string GetToken(SystemUser user, IList<string> roles, string roleInfo)
        {
            ArgumentNullException.ThrowIfNull(user);

            var roleClaims = roles.Select(role => new Claim(ClaimTypes.Role, role));
            var userClaims = new List<Claim>
            {
                new(type: Constants.UserIdClaimType, user.Id),
                new(type: JwtRegisteredClaimNames.GivenName, user.FullName),
                new(type: Constants.RoleInfoClaimType, roleInfo),
            };

            userClaims.AddRange(roleClaims);

            var signingCreds = new SigningCredentials(
                    new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_settings.JwtSecretKey)),
                    SecurityAlgorithms.HmacSha256);

            var jwt = new JwtSecurityToken(
                issuer: _settings.JwtIssuer,
                audience: _settings.JwtAudience,
                signingCredentials: signingCreds,
                claims: userClaims,
                expires: DateTime.Now.AddDays(DaysExpirationTerm));

            var encodedJwt = new JwtSecurityTokenHandler().WriteToken(jwt);

            return encodedJwt;
        }

        public bool ValidateToken(string token)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            try
            {
                tokenHandler.ValidateToken(
                token,
                new TokenValidationParameters
                {
                    ValidateIssuer = true,
                    ValidIssuer = _settings.JwtIssuer,
                    ValidateAudience = true,
                    ValidAudience = _settings.JwtAudience,
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_settings.JwtSecretKey)),
                    ValidateLifetime = true,
                    LifetimeValidator =
                        (before, exprise, localToken, parameters) =>
                        {
                            if (exprise.HasValue)
                            {
                                return exprise.Value > DateTime.UtcNow;
                            }

                            return true;
                        },
                    RequireExpirationTime = true,
                },
                out var _);
            }
            catch (SecurityTokenException)
            {
                return false;
            }
            catch (ArgumentException)
            {
                return false;
            }

            return true;
        }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Models\CalculationCheckResult.cs 
 
﻿using System.Collections.Generic;

namespace EmisTracking.Services.Models
{
    public class CalculationCheckResult
    {
        public string MethodologyId { get; set; }
        public string MethodologyName { get; set; }
        public string EmissionSourceId { get; set; }
        public string EmissionSourceName { get; set; }
        public int Month { get; set; }
        public int Year { get; set; }
        public bool CanBeCalculated { get; set; }

        public List<CalculationParameter> Parameters { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Models\CalculationParameter.cs 
 
﻿using EmisTracking.Services.Enums;

namespace EmisTracking.Services.Models
{
    public class CalculationParameter
    {
        public string SourceSubstanceId { get; set; }
        public string SourceSubstanceName { get; set; }
        public string MethodologyParameterId { get; set; }
        public string ParameterValueId { get; set; }
        public ParameterType ParameterType { get; set; }
        public string Name { get; set; }
        public double Value { get; set; }
        public bool IsFilled { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Options\JwtTokenSettings.cs 
 
﻿namespace EmisTracking.Services.Options
{
    public class JwtTokenSettings
    {
        public const string JwtConfigSectionKey = "JwtTokenSettings";

        public const string JwtIssuerConfigKey = "JwtIssuer";
        public const string JwtAudienceConfigKey = "JwtAudience";
        public const string JwtSecretKeyConfigKey = "JwtSecretKey";

        public string JwtIssuer { get; set; }

        public string JwtAudience { get; set; }

        public string JwtSecretKey { get; set; }
    }
}
 
emission-tracking-app\src\EmisTracking.Services\Services\AreasService.cs 
 
﻿using AutoMapper;
using EmisTracking.Localization;
using EmisTracking.Services.Entities;
using EmisTracking.Services.Exceptions;
using EmisTracking.Services.Interfaces;
using EmisTracking.Services.Models;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading.Tasks;

namespace EmisTracking.Services.Services
{
    public class AreasService(IRepository<Area> repository, IMapper mapper) : GenericEntityService<Area>(repository, mapper)
    {
        protected override Expression<Func<Area, object>>[] DependenciesIncludes => [];

        protected override async Task ValidateAsync(Area item)
        {
            var errors = new List<FieldError>();

            if (string.IsNullOrEmpty(item.Name))
            {
                errors.Add(new FieldError
                {
                    Field = nameof(item.Name),
                    Message = LangResources.MustBeFilledMessage
                });
            }

            var existingArea = await _repository.GetAll(a =>
                a.Id != item.Id && a.Name == item.Name)
                .ToListAsync();

            if (existingArea != null)
            {
                errors.Add(new FieldError
                {
                    Field = string.Empty,
                    Message = "Уже существует площадка с тем же именем"
                });
            }

            if (errors.Count != 0)
            {
                throw new BusinessLogicException { FieldErrors = errors };
            }
        }
    }
}

emission-tracking-app\src\EmisTracking.Services\Services\GenericEntityService.cs 
 
﻿using AutoMapper;
using EmisTracking.Services.Exceptions;
using EmisTracking.Services.Interfaces;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Threading.Tasks;

namespace EmisTracking.Services.Services
{
    public abstract class GenericEntityService<TEntity>(IRepository<TEntity> repository, IMapper mapper)
        : IEntityService<TEntity>
        where TEntity : class, IEntity
    {
        private protected readonly IRepository<TEntity> _repository = repository;
        private protected readonly IMapper _mapper = mapper;

        protected abstract Expression<Func<TEntity, object>>[] DependenciesIncludes { get; }

        public virtual Task<List<TEntity>> GetAllAsync(Expression<Func<TEntity, bool>> predicate = null, bool loadDependencies = false)
        {
            try
            {
                return loadDependencies ?
                    _repository.GetAll(predicate, DependenciesIncludes).ToListAsync()
                    : _repository.GetAll(predicate).ToListAsync();
            }
            catch (InvalidOperationException ex)
            {
                throw new BusinessLogicException(ex.Message, ex);
            }
        }

        public Task<TEntity> GetByIdAsync(string id, bool loadDependencies = false)
        {
            try
            {
                ArgumentNullException.ThrowIfNull(id);

                return loadDependencies ?
                    _repository.GetByIdAsync(id, DependenciesIncludes)
                    : _repository.GetByIdAsync(id);
            }
            catch (ArgumentNullException ex)
            {
                throw new BusinessLogicException(ex.Message, ex);
            }
        }

        public virtual async Task<string> AddAsync(TEntity entity)
        {
            try
            {
                await ValidateAsync(entity);

                return await _repository.CreateAsync(_mapper.Map<TEntity>(entity));
            }
            catch (ArgumentNullException ex)
            {
                throw new BusinessLogicException(ex.Message, ex);
            }
            catch (DbUpdateException ex)
            {
                throw new BusinessLogicException(ex.Message, ex);
            }
        }

        public async virtual Task<bool> UpdateAsync(TEntity entity)
        {
            try
            {
                await ValidateAsync(entity);

                var mappedEntity = _mapper.Map<TEntity>(entity);

                return await _repository.UpdateAsync(mappedEntity);
            }
            catch (ArgumentNullException ex)
            {
                throw new BusinessLogicException(ex.Message, ex);
            }
        }

        public Task<bool> DeleteAsync(string id)
        {
            try
            {
                ArgumentNullException.ThrowIfNull(id);

                return _repository.DeleteAsync(id);
            }
            catch (ArgumentNullException ex)
            {
                throw new BusinessLogicException(ex.Message, ex);
            }
        }

        protected abstract Task ValidateAsync(TEntity item);
    }
} 

emission-tracking-app\src\EmisTracking.Services\Services\GrossEmissionsService.cs 
 
﻿using AutoMapper;
using EmisTracking.Localization;
using EmisTracking.Services.Entities;
using EmisTracking.Services.Enums;
using EmisTracking.Services.Exceptions;
using EmisTracking.Services.Interfaces;
using EmisTracking.Services.Models;
using Microsoft.EntityFrameworkCore;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading.Tasks;

namespace EmisTracking.Services.Services
{
    public interface IGrossEmissionService : IEntityService<GrossEmission>
    {
        public Task<CalculationCheckResult> CheckCalculationAsync(
            string methodologyId,
            string methodologyName,
            string emissionSourceId,
            string emissionSourceName,
            int month, int year);

        public List<GrossEmission> Calculate(string methodologyId, string emissionSourceId, string month, string year);
    }

    public class GrossEmissionsService(
        IRepository<GrossEmission> repository,
        IRepository<MethodologyParameter> methodologyParameterRepository,
        IRepository<ParameterValue> parameterValueRepository,
        IRepository<OperatingTime> operatingTimeService,
        IRepository<Consumption> consumptionService,
        IRepository<SourceSubstance> sourceSubstancesRepository,
        IRepository<SpecificIndicator> specificIndicatorService,
        IRepository<ConsumptionGroup> consumptionGroupRepository,
        IMapper mapper) : GenericEntityService<GrossEmission>(repository, mapper), IGrossEmissionService
    {
        private readonly IRepository<MethodologyParameter> _methodologyParameterRepository = methodologyParameterRepository;
        private readonly IRepository<ParameterValue> _parameterValueRepository = parameterValueRepository;
        private readonly IRepository<OperatingTime> _operatingTimeRepository = operatingTimeService;
        private readonly IRepository<Consumption> _consumptionRepository = consumptionService;
        private readonly IRepository<ConsumptionGroup> _consumptionGroupRepository = consumptionGroupRepository;
        private readonly IRepository<SourceSubstance> _sourceSubstancesRepository = sourceSubstancesRepository;
        private readonly IRepository<SpecificIndicator> _specificIndicatorRepository = specificIndicatorService;

        protected override Expression<Func<GrossEmission, object>>[] DependenciesIncludes =>
        [
            x => x.SourceSubstance,
            x => x.Methodology,
            x => x.Tax
        ];

        public override Task<List<GrossEmission>> GetAllAsync(
            Expression<Func<GrossEmission, bool>> predicate = null, bool loadDependencies = false)
        {
            try
            {
                return (loadDependencies ?
                    _repository.GetAll(predicate, DependenciesIncludes)
                    : _repository.GetAll(predicate))
                        .OrderByDescending(x => x.Year)
                        .ThenByDescending(x => x.Month)
                        .ToListAsync();
            }
            catch (InvalidOperationException ex)
            {
                throw new BusinessLogicException(ex.Message, ex);
            }
        }

        public async Task<CalculationCheckResult> CheckCalculationAsync(
            string methodologyId,
            string methodologyName,
            string emissionSourceId,
            string emissionSourceName,
            int month, int year)
        {
            var methodologyParameters = await _methodologyParameterRepository
                .GetAll(p => p.MethodologyId == methodologyId)
                .ToListAsync();

            var sourceSubstances = await _sourceSubstancesRepository
                .GetAll(s => s.EmissionSourceId == emissionSourceId && s.IsRegulated,
                    includes: x => x.Pollutant)
                .ToListAsync();

            var sourcePollutantsIds = sourceSubstances.Select(x => x.Pollutant.Id).Distinct().ToList();

            var methodologyConsumptionGroups = await _consumptionGroupRepository
                .GetAll(g => g.MethodologyId == methodologyId)
                .ToListAsync();

            var methodologySpecificIndicators = await _specificIndicatorRepository
                .GetAll(i => methodologyConsumptionGroups.Select(g => g.Id).Contains(i.ConsumptionGroupId),
                includes: x => x.Pollutant)
                .ToListAsync();

            var methodologyPollutantsIds = methodologySpecificIndicators.Distinct()
                .Select(x => x.Pollutant.Id)
                .Distinct()
                .ToList();

            var missingPollutants = methodologyPollutantsIds.Except(sourcePollutantsIds).ToList();

            if (missingPollutants.Count != 0)
            {
                var missingPollutantsDetails = methodologySpecificIndicators
                    .Where(i => missingPollutants.Contains(i.Pollutant.Id))
                    .Select(i => new KeyValuePair<string, string>(i.Pollutant.Id, i.Pollutant.Name))
                    .ToList();

                var serializedData = JsonConvert.SerializeObject(missingPollutantsDetails);

                throw new BusinessLogicException(LangResources.MissingMethodologyPollutants) { SerializedData = serializedData };
            }

            var parameters = new List<CalculationParameter>();

            var existingSourceParameters = new List<ParameterValue>();

            // Получить все параметры, связанные с веществами источника
            foreach (var sourceSubstance in sourceSubstances)
            {
                var substanceParameters = await _parameterValueRepository.GetAll(p =>
                    p.Month == month
                    && p.Year == year
                    && p.SourceSubstanceId == sourceSubstance.Id, includes: p => p.MethodologyParameter).ToListAsync();

                existingSourceParameters.AddRange(substanceParameters);
            }

            foreach (var methodologyParameter in methodologyParameters)
            {
                bool isSubstanceRelated = methodologyParameter.ParameterType == ParameterType.GasCleaningUnitPercent
                                         || methodologyParameter.ParameterType == ParameterType.ConsumptionMass
                                         || methodologyParameter.ParameterType == ParameterType.SpecificIndicator;

                var createdParameters = await FindOrCreateParameterAsync(
                        emissionSourceId,
                        methodologyParameter,
                        month,
                        year,
                        existingSourceParameters,
                        methodologySpecificIndicators,
                        isSubstanceRelated ? sourceSubstances : null);

                parameters.AddRange(createdParameters);
            }

            var result = new CalculationCheckResult
            {
                MethodologyId = methodologyId,
                MethodologyName = methodologyName,
                EmissionSourceId = emissionSourceId,
                EmissionSourceName = emissionSourceName,
                Month = month,
                Year = year,
                Parameters = parameters,
                CanBeCalculated = parameters.All(p => p.IsFilled)
            };

            return result;
        }

        public List<GrossEmission> Calculate(string methodologyId, string emissionSourceId, string month, string year)
        {
            throw new NotImplementedException();
        }

        private async Task<List<CalculationParameter>> FindOrCreateParameterAsync(
            string emissionSourceId,
            MethodologyParameter parameter,
            int month, int year,
            List<ParameterValue> existingSourceParameters,
            List<SpecificIndicator> methodologySpecificIndicators,
            List<SourceSubstance> sourceSubstances)
        {
            var result = new List<CalculationParameter>();

            switch (parameter.ParameterType)
            {
                case ParameterType.Numeric:
                    {
                        var calculationParameter = await TryFindOrCreateParameterAsync(
                            existingSourceParameters,
                            parameter.Id,
                            parameter.Name,
                            parameter.ParameterType,
                            sourceSubstances,
                            valueFromTable: null,
                            month, year);

                        result.AddRange(calculationParameter);
                        break;
                    }
                case ParameterType.OperatingTime:
                    {
                        var existingOperatingTime = await _operatingTimeRepository.GetAll(o =>
                            o.Year == year
                            && o.Month == month
                            && o.EmissionSourceId == emissionSourceId).FirstOrDefaultAsync();

                        var calculationParameters = await TryFindOrCreateParameterAsync(
                            existingSourceParameters,
                            parameter.Id,
                            parameter.Name,
                            parameter.ParameterType,
                            sourceSubstances,
                            valueFromTable: existingOperatingTime?.Hours,
                            month, year);

                        result.AddRange(calculationParameters);
                        break;
                    }
                case ParameterType.GasCleaningUnitPercent:
                    {
                        foreach (var sourceSubstance in sourceSubstances)
                        {
                            var existingGcuPercent = sourceSubstance.PurificationPercentage;

                            var calculationParameters = await TryFindOrCreateParameterAsync(
                                    existingSourceParameters,
                                    parameter.Id,
                                    parameter.Name,
                                    parameter.ParameterType,
                                    sourceSubstances,
                                    valueFromTable: existingGcuPercent,
                                    month, year);

                            result.AddRange(calculationParameters);
                        }

                        break;
                    }
                case ParameterType.ConsumptionMass:
                    {
                        foreach (var sourceSubstance in sourceSubstances)
                        {
                            var groupsWithPollutants = methodologySpecificIndicators.Where(i =>
                                i.Pollutant.Id == sourceSubstance.Pollutant.Id).Select(x => x.ConsumptionGroupId);

                            var consumptionTotalMass = await _consumptionRepository.GetAll(x =>
                                x.Month == month
                                && x.Year == year
                                && groupsWithPollutants.Contains(x.Id)).SumAsync(x => x.Mass);

                            var calculationParameters = await TryFindOrCreateParameterAsync(
                                    existingSourceParameters,
                                    parameter.Id,
                                    parameter.Name,
                                    parameter.ParameterType,
                                    sourceSubstances,
                                    valueFromTable: consumptionTotalMass,
                                    month, year);

                            result.AddRange(calculationParameters);
                        }

                        break;
                    }
                case ParameterType.SpecificIndicator:
                    {
                        foreach (var sourceSubstance in sourceSubstances)
                        {
                            var foundSpecificIndicator = methodologySpecificIndicators.FirstOrDefault(i =>
                                i.PollutantId == sourceSubstance.Id);

                            var calculationParameters = await TryFindOrCreateParameterAsync(
                                    existingSourceParameters,
                                    parameter.Id,
                                    parameter.Name,
                                    parameter.ParameterType,
                                    sourceSubstances,
                                    valueFromTable: foundSpecificIndicator.Value,
                                    month, year);

                            result.AddRange(calculationParameters);
                        }

                        break;
                    }
                default:
                    throw new BusinessLogicException(
                        string.Format(LangResources.UnknownParameterTypeTemplate, parameter.ParameterType, parameter.Id));
            }

            return result;
        }

        private async Task<List<CalculationParameter>> TryFindOrCreateParameterAsync(
            List<ParameterValue> existingSourceParameters,
            string methodologyParameterId,
            string parameterName,
            ParameterType parameterType,
            List<SourceSubstance> sourceSubstances,
            double? valueFromTable, int month, int year)
        {
            var items = new List<CalculationParameter>();

            foreach (var sourceSubstance in sourceSubstances)
            {
                var existingParameter = existingSourceParameters.FirstOrDefault(p =>
                    p.MethodologyParameter.Id == methodologyParameterId
                    && p.SourceSubstanceId == sourceSubstance.Id);

                if (valueFromTable != null)
                {
                    if (existingParameter == null)
                    {
                        existingParameter = new ParameterValue
                        {
                            MethodologyParameterId = methodologyParameterId,
                            SourceSubstanceId = sourceSubstance.Id,
                            Month = month,
                            Year = year,
                            Value = valueFromTable.Value,
                        };

                        existingParameter.Id = await _parameterValueRepository.CreateAsync(existingParameter);
                    }
                    else if (existingParameter.Value != valueFromTable.Value)
                    {
                        existingParameter.Value = valueFromTable.Value;

                        await _parameterValueRepository.UpdateAsync(existingParameter);
                    }
                }

                items.Add(new CalculationParameter
                {
                    IsFilled = existingParameter != null,
                    SourceSubstanceId = sourceSubstance.Id,
                    SourceSubstanceName = sourceSubstance.Pollutant.Name,
                    MethodologyParameterId = methodologyParameterId,
                    Name = parameterName,
                    ParameterType = parameterType,
                    ParameterValueId = existingParameter.Id,
                    Value = existingParameter != null ? existingParameter.Value : Constants.DefaultParameterValue,
                });
            }

            return items;
        }
    }
} 
emission-tracking-app\src\EmisTracking.Services\Services\IUsersService.cs 
 
﻿using EmisTracking.Services.Entities;
using EmisTracking.Services.Interfaces;
using System.Threading.Tasks;

namespace EmisTracking.Services.Services
{
    public interface IUsersService : IEntityService<User>
    {
        public Task<User> GetBySystemUserId(string systemUserId);
    }
} 
emission-tracking-app\src\EmisTracking.Services\Services\NcalcCalculationService.cs 
 
﻿using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace EmisTracking.Services.Services
{
    public interface ICalculationService
    {
        public Task<double> CalculateAsync(string formula, Dictionary<string, double> parameterValues);
    }

    public class NcalcCalculationService : ICalculationService
    {
        public async Task<double> CalculateAsync(string formula, Dictionary<string, double> parameterValues)
        {
            var expression = new NCalc.AsyncExpression(formula);

            foreach (var kv in parameterValues)
            {
                expression.Parameters[kv.Key] = kv.Value;
            }

            var value = await expression.EvaluateAsync();
            return Convert.ToDouble(value);
        }
    }
}
